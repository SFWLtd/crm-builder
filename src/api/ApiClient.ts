/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v8.6.6221.23503 (NJsonSchema v7.6.6221.22528) (http://NSwag.org)
// </auto-generated>
//----------------------


export interface IBuildsClient {
    getBuild(id: string): Promise<GlobalJsonResultOfBuildDto>;
    getBuilds(id: string): Promise<GlobalJsonResultOfIEnumerableOfBuildDto>;
    newBuild(request: NewBuildRequest, id: string): Promise<GlobalJsonResultOfBuildDto>;
    updateBuild(request: UpdateBuildRequest, id: string): Promise<GlobalJsonResultOfBuildDto>;
    deleteBuild(request: DeleteBuildRequest, id: string): Promise<GlobalJsonResultOfEmptyResult>;
}

export class BuildsClient implements IBuildsClient {
    private baseUrl: string; 
    private http: any
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : window;
    }

    getBuild(id: string): Promise<GlobalJsonResultOfBuildDto> {
        let url_ = this.baseUrl + "/api/Builds/GetBuild/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));

        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response : Response) => {
            return this.processGetBuild(response);
        });
    }

    protected processGetBuild(response: Response): Promise<GlobalJsonResultOfBuildDto> {
        return response.text().then((responseText) => {
            const status = response.status; 

            
                let result200: GlobalJsonResultOfBuildDto = null;
                let resultData200 = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
                result200 = resultData200 ? GlobalJsonResultOfBuildDto.fromJS(resultData200) : null;
                return result200;
            
        });
    }

    getBuilds(id: string): Promise<GlobalJsonResultOfIEnumerableOfBuildDto> {
        let url_ = this.baseUrl + "/api/Builds/GetBuilds/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));

        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response : Response) => {
            return this.processGetBuilds(response);
        });
    }

    protected processGetBuilds(response: Response): Promise<GlobalJsonResultOfIEnumerableOfBuildDto> {
        return response.text().then((responseText) => {
            const status = response.status; 

            
                let result200: GlobalJsonResultOfIEnumerableOfBuildDto = null;
                let resultData200 = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
                result200 = resultData200 ? GlobalJsonResultOfIEnumerableOfBuildDto.fromJS(resultData200) : null;
                return result200;
            
        });
    }

    newBuild(request: NewBuildRequest, id: string): Promise<GlobalJsonResultOfBuildDto> {
        let url_ = this.baseUrl + "/api/Builds/NewBuild/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));

        const content_ = JSON.stringify(request ? request.toJS() : null);
        return this.http.fetch(url_, {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response : Response) => {
            return this.processNewBuild(response);
        });
    }

    protected processNewBuild(response: Response): Promise<GlobalJsonResultOfBuildDto> {
        return response.text().then((responseText) => {
            const status = response.status; 

            
                let result200: GlobalJsonResultOfBuildDto = null;
                let resultData200 = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
                result200 = resultData200 ? GlobalJsonResultOfBuildDto.fromJS(resultData200) : null;
                return result200;
            
        });
    }

    updateBuild(request: UpdateBuildRequest, id: string): Promise<GlobalJsonResultOfBuildDto> {
        let url_ = this.baseUrl + "/api/Builds/UpdateBuild/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));

        const content_ = JSON.stringify(request ? request.toJS() : null);
        return this.http.fetch(url_, {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response : Response) => {
            return this.processUpdateBuild(response);
        });
    }

    protected processUpdateBuild(response: Response): Promise<GlobalJsonResultOfBuildDto> {
        return response.text().then((responseText) => {
            const status = response.status; 

            
                let result200: GlobalJsonResultOfBuildDto = null;
                let resultData200 = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
                result200 = resultData200 ? GlobalJsonResultOfBuildDto.fromJS(resultData200) : null;
                return result200;
            
        });
    }

    deleteBuild(request: DeleteBuildRequest, id: string): Promise<GlobalJsonResultOfEmptyResult> {
        let url_ = this.baseUrl + "/api/Builds/DeleteBuild/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));

        const content_ = JSON.stringify(request ? request.toJS() : null);
        return this.http.fetch(url_, {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response : Response) => {
            return this.processDeleteBuild(response);
        });
    }

    protected processDeleteBuild(response: Response): Promise<GlobalJsonResultOfEmptyResult> {
        return response.text().then((responseText) => {
            const status = response.status; 

            
                let result200: GlobalJsonResultOfEmptyResult = null;
                let resultData200 = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
                result200 = resultData200 ? GlobalJsonResultOfEmptyResult.fromJS(resultData200) : null;
                return result200;
            
        });
    }

    protected throwException(message: string, status: number, response: string, result?: any): any {
        if(result !== null && result !== undefined)
            throw result;
        else
            throw new SwaggerException(message, status, response);
    }
}

export interface ISolutionsClient {
    getAll(id: string): Promise<GlobalJsonResultOfIEnumerableOfSolutionDto>;
}

export class SolutionsClient implements ISolutionsClient {
    private baseUrl: string; 
    private http: any
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : window;
    }

    getAll(id: string): Promise<GlobalJsonResultOfIEnumerableOfSolutionDto> {
        let url_ = this.baseUrl + "/api/Solutions/GetAll/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));

        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response : Response) => {
            return this.processGetAll(response);
        });
    }

    protected processGetAll(response: Response): Promise<GlobalJsonResultOfIEnumerableOfSolutionDto> {
        return response.text().then((responseText) => {
            const status = response.status; 

            
                let result200: GlobalJsonResultOfIEnumerableOfSolutionDto = null;
                let resultData200 = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
                result200 = resultData200 ? GlobalJsonResultOfIEnumerableOfSolutionDto.fromJS(resultData200) : null;
                return result200;
            
        });
    }

    protected throwException(message: string, status: number, response: string, result?: any): any {
        if(result !== null && result !== undefined)
            throw result;
        else
            throw new SwaggerException(message, status, response);
    }
}

export interface IInstallationClient {
    getInstallationStatus(id: string): Promise<GlobalJsonResultOfInstallationStatusResult>;
    startInstallation(request: StartInstallationRequest, id: string): Promise<GlobalJsonResultOfInstallationResult>;
    installNextComponent(request: ComponentInstallationRequest, id: string): Promise<GlobalJsonResultOfInstallationResult>;
    rollbackComponentsForVersion(request: RollbackRequest, id: string): Promise<GlobalJsonResultOfRollbackResult>;
}

export class InstallationClient implements IInstallationClient {
    private baseUrl: string; 
    private http: any
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : window;
    }

    getInstallationStatus(id: string): Promise<GlobalJsonResultOfInstallationStatusResult> {
        let url_ = this.baseUrl + "/api/Installation/GetInstallationStatus/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));

        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response : Response) => {
            return this.processGetInstallationStatus(response);
        });
    }

    protected processGetInstallationStatus(response: Response): Promise<GlobalJsonResultOfInstallationStatusResult> {
        return response.text().then((responseText) => {
            const status = response.status; 

            
                let result200: GlobalJsonResultOfInstallationStatusResult = null;
                let resultData200 = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
                result200 = resultData200 ? GlobalJsonResultOfInstallationStatusResult.fromJS(resultData200) : null;
                return result200;
            
        });
    }

    startInstallation(request: StartInstallationRequest, id: string): Promise<GlobalJsonResultOfInstallationResult> {
        let url_ = this.baseUrl + "/api/Installation/StartInstallation/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));

        const content_ = JSON.stringify(request ? request.toJS() : null);
        return this.http.fetch(url_, {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response : Response) => {
            return this.processStartInstallation(response);
        });
    }

    protected processStartInstallation(response: Response): Promise<GlobalJsonResultOfInstallationResult> {
        return response.text().then((responseText) => {
            const status = response.status; 

            
                let result200: GlobalJsonResultOfInstallationResult = null;
                let resultData200 = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
                result200 = resultData200 ? GlobalJsonResultOfInstallationResult.fromJS(resultData200) : null;
                return result200;
            
        });
    }

    installNextComponent(request: ComponentInstallationRequest, id: string): Promise<GlobalJsonResultOfInstallationResult> {
        let url_ = this.baseUrl + "/api/Installation/InstallNextComponent/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));

        const content_ = JSON.stringify(request ? request.toJS() : null);
        return this.http.fetch(url_, {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response : Response) => {
            return this.processInstallNextComponent(response);
        });
    }

    protected processInstallNextComponent(response: Response): Promise<GlobalJsonResultOfInstallationResult> {
        return response.text().then((responseText) => {
            const status = response.status; 

            
                let result200: GlobalJsonResultOfInstallationResult = null;
                let resultData200 = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
                result200 = resultData200 ? GlobalJsonResultOfInstallationResult.fromJS(resultData200) : null;
                return result200;
            
        });
    }

    rollbackComponentsForVersion(request: RollbackRequest, id: string): Promise<GlobalJsonResultOfRollbackResult> {
        let url_ = this.baseUrl + "/api/Installation/RollbackComponentsForVersion/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));

        const content_ = JSON.stringify(request ? request.toJS() : null);
        return this.http.fetch(url_, {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response : Response) => {
            return this.processRollbackComponentsForVersion(response);
        });
    }

    protected processRollbackComponentsForVersion(response: Response): Promise<GlobalJsonResultOfRollbackResult> {
        return response.text().then((responseText) => {
            const status = response.status; 

            
                let result200: GlobalJsonResultOfRollbackResult = null;
                let resultData200 = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
                result200 = resultData200 ? GlobalJsonResultOfRollbackResult.fromJS(resultData200) : null;
                return result200;
            
        });
    }

    protected throwException(message: string, status: number, response: string, result?: any): any {
        if(result !== null && result !== undefined)
            throw result;
        else
            throw new SwaggerException(message, status, response);
    }
}

export interface ISessionClient {
    checkSessionExists(id: string): Promise<GlobalJsonResultOfBoolean>;
    newSession(request: NewSessionRequest, id: string): Promise<GlobalJsonResultOfBoolean>;
    endSession(id: string): Promise<GlobalJsonResultOfEmptyResult>;
}

export class SessionClient implements ISessionClient {
    private baseUrl: string; 
    private http: any
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : window;
    }

    checkSessionExists(id: string): Promise<GlobalJsonResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Session/CheckSessionExists/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));

        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response : Response) => {
            return this.processCheckSessionExists(response);
        });
    }

    protected processCheckSessionExists(response: Response): Promise<GlobalJsonResultOfBoolean> {
        return response.text().then((responseText) => {
            const status = response.status; 

            
                let result200: GlobalJsonResultOfBoolean = null;
                let resultData200 = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
                result200 = resultData200 ? GlobalJsonResultOfBoolean.fromJS(resultData200) : null;
                return result200;
            
        });
    }

    newSession(request: NewSessionRequest, id: string): Promise<GlobalJsonResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Session/NewSession/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));

        const content_ = JSON.stringify(request ? request.toJS() : null);
        return this.http.fetch(url_, {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response : Response) => {
            return this.processNewSession(response);
        });
    }

    protected processNewSession(response: Response): Promise<GlobalJsonResultOfBoolean> {
        return response.text().then((responseText) => {
            const status = response.status; 

            
                let result200: GlobalJsonResultOfBoolean = null;
                let resultData200 = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
                result200 = resultData200 ? GlobalJsonResultOfBoolean.fromJS(resultData200) : null;
                return result200;
            
        });
    }

    endSession(id: string): Promise<GlobalJsonResultOfEmptyResult> {
        let url_ = this.baseUrl + "/api/Session/EndSession/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));

        const content_ = "";
        return this.http.fetch(url_, {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response : Response) => {
            return this.processEndSession(response);
        });
    }

    protected processEndSession(response: Response): Promise<GlobalJsonResultOfEmptyResult> {
        return response.text().then((responseText) => {
            const status = response.status; 

            
                let result200: GlobalJsonResultOfEmptyResult = null;
                let resultData200 = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
                result200 = resultData200 ? GlobalJsonResultOfEmptyResult.fromJS(resultData200) : null;
                return result200;
            
        });
    }

    protected throwException(message: string, status: number, response: string, result?: any): any {
        if(result !== null && result !== undefined)
            throw result;
        else
            throw new SwaggerException(message, status, response);
    }
}

export class GlobalJsonResultOfBuildDto { 
    successful: boolean; 
    result: BuildDto; 
    errorMessage: string; 
    stackTrace: string; 
    statusCode: HttpStatusCode;

    constructor(data?: any) {
        if (data !== undefined) {
            this.successful = data["Successful"] !== undefined ? data["Successful"] : null;
            this.result = data["Result"] ? BuildDto.fromJS(data["Result"]) : null;
            this.errorMessage = data["ErrorMessage"] !== undefined ? data["ErrorMessage"] : null;
            this.stackTrace = data["StackTrace"] !== undefined ? data["StackTrace"] : null;
            this.statusCode = data["StatusCode"] !== undefined ? data["StatusCode"] : null;
        }
    }

    static fromJS(data: any): GlobalJsonResultOfBuildDto {
        return new GlobalJsonResultOfBuildDto(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["Successful"] = this.successful !== undefined ? this.successful : null;
        data["Result"] = this.result ? this.result.toJS() : null;
        data["ErrorMessage"] = this.errorMessage !== undefined ? this.errorMessage : null;
        data["StackTrace"] = this.stackTrace !== undefined ? this.stackTrace : null;
        data["StatusCode"] = this.statusCode !== undefined ? this.statusCode : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        const json = this.toJSON();
        return new GlobalJsonResultOfBuildDto(JSON.parse(json));
    }
}

export class BuildDto { 
    id: string; 
    name: string; 
    buildVersioningType: BuildVersioningType; 
    versionMajor: number; 
    versionMinor: number; 
    targetAuthenticationType: AuthenticationType; 
    targetCrmUrl: string; 
    targetDomain: string; 
    targetUsername: string; 
    targetEmailAddress: string; 
    targetPassword: string; 
    selectedSolutionId: string;

    constructor(data?: any) {
        if (data !== undefined) {
            this.id = data["Id"] !== undefined ? data["Id"] : null;
            this.name = data["Name"] !== undefined ? data["Name"] : null;
            this.buildVersioningType = data["BuildVersioningType"] !== undefined ? data["BuildVersioningType"] : null;
            this.versionMajor = data["VersionMajor"] !== undefined ? data["VersionMajor"] : null;
            this.versionMinor = data["VersionMinor"] !== undefined ? data["VersionMinor"] : null;
            this.targetAuthenticationType = data["TargetAuthenticationType"] !== undefined ? data["TargetAuthenticationType"] : null;
            this.targetCrmUrl = data["TargetCrmUrl"] !== undefined ? data["TargetCrmUrl"] : null;
            this.targetDomain = data["TargetDomain"] !== undefined ? data["TargetDomain"] : null;
            this.targetUsername = data["TargetUsername"] !== undefined ? data["TargetUsername"] : null;
            this.targetEmailAddress = data["TargetEmailAddress"] !== undefined ? data["TargetEmailAddress"] : null;
            this.targetPassword = data["TargetPassword"] !== undefined ? data["TargetPassword"] : null;
            this.selectedSolutionId = data["SelectedSolutionId"] !== undefined ? data["SelectedSolutionId"] : null;
        }
    }

    static fromJS(data: any): BuildDto {
        return new BuildDto(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["Id"] = this.id !== undefined ? this.id : null;
        data["Name"] = this.name !== undefined ? this.name : null;
        data["BuildVersioningType"] = this.buildVersioningType !== undefined ? this.buildVersioningType : null;
        data["VersionMajor"] = this.versionMajor !== undefined ? this.versionMajor : null;
        data["VersionMinor"] = this.versionMinor !== undefined ? this.versionMinor : null;
        data["TargetAuthenticationType"] = this.targetAuthenticationType !== undefined ? this.targetAuthenticationType : null;
        data["TargetCrmUrl"] = this.targetCrmUrl !== undefined ? this.targetCrmUrl : null;
        data["TargetDomain"] = this.targetDomain !== undefined ? this.targetDomain : null;
        data["TargetUsername"] = this.targetUsername !== undefined ? this.targetUsername : null;
        data["TargetEmailAddress"] = this.targetEmailAddress !== undefined ? this.targetEmailAddress : null;
        data["TargetPassword"] = this.targetPassword !== undefined ? this.targetPassword : null;
        data["SelectedSolutionId"] = this.selectedSolutionId !== undefined ? this.selectedSolutionId : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        const json = this.toJSON();
        return new BuildDto(JSON.parse(json));
    }
}

export enum BuildVersioningType {
    JulianDate = 0, 
}

export enum AuthenticationType {
    Dynamics365 = 0, 
    Ifd = 1, 
    OnPremise = 2, 
}

export enum HttpStatusCode {
    Continue = 100, 
    SwitchingProtocols = 101, 
    OK = 200, 
    Created = 201, 
    Accepted = 202, 
    NonAuthoritativeInformation = 203, 
    NoContent = 204, 
    ResetContent = 205, 
    PartialContent = 206, 
    MultipleChoices = 300, 
    Ambiguous = 300, 
    MovedPermanently = 301, 
    Moved = 301, 
    Found = 302, 
    Redirect = 302, 
    SeeOther = 303, 
    RedirectMethod = 303, 
    NotModified = 304, 
    UseProxy = 305, 
    Unused = 306, 
    TemporaryRedirect = 307, 
    RedirectKeepVerb = 307, 
    BadRequest = 400, 
    Unauthorized = 401, 
    PaymentRequired = 402, 
    Forbidden = 403, 
    NotFound = 404, 
    MethodNotAllowed = 405, 
    NotAcceptable = 406, 
    ProxyAuthenticationRequired = 407, 
    RequestTimeout = 408, 
    Conflict = 409, 
    Gone = 410, 
    LengthRequired = 411, 
    PreconditionFailed = 412, 
    RequestEntityTooLarge = 413, 
    RequestUriTooLong = 414, 
    UnsupportedMediaType = 415, 
    RequestedRangeNotSatisfiable = 416, 
    ExpectationFailed = 417, 
    UpgradeRequired = 426, 
    InternalServerError = 500, 
    NotImplemented = 501, 
    BadGateway = 502, 
    ServiceUnavailable = 503, 
    GatewayTimeout = 504, 
    HttpVersionNotSupported = 505, 
}

export class GlobalJsonResultOfIEnumerableOfBuildDto { 
    successful: boolean; 
    result: BuildDto[]; 
    errorMessage: string; 
    stackTrace: string; 
    statusCode: HttpStatusCode;

    constructor(data?: any) {
        if (data !== undefined) {
            this.successful = data["Successful"] !== undefined ? data["Successful"] : null;
            if (data["Result"] && data["Result"].constructor === Array) {
                this.result = [];
                for (let item of data["Result"])
                    this.result.push(BuildDto.fromJS(item));
            }
            this.errorMessage = data["ErrorMessage"] !== undefined ? data["ErrorMessage"] : null;
            this.stackTrace = data["StackTrace"] !== undefined ? data["StackTrace"] : null;
            this.statusCode = data["StatusCode"] !== undefined ? data["StatusCode"] : null;
        }
    }

    static fromJS(data: any): GlobalJsonResultOfIEnumerableOfBuildDto {
        return new GlobalJsonResultOfIEnumerableOfBuildDto(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["Successful"] = this.successful !== undefined ? this.successful : null;
        if (this.result && this.result.constructor === Array) {
            data["Result"] = [];
            for (let item of this.result)
                data["Result"].push(item.toJS());
        }
        data["ErrorMessage"] = this.errorMessage !== undefined ? this.errorMessage : null;
        data["StackTrace"] = this.stackTrace !== undefined ? this.stackTrace : null;
        data["StatusCode"] = this.statusCode !== undefined ? this.statusCode : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        const json = this.toJSON();
        return new GlobalJsonResultOfIEnumerableOfBuildDto(JSON.parse(json));
    }
}

export class NewBuildRequest { 
    name: string; 
    buildVersioningType: BuildVersioningType; 
    versionMajor: number; 
    versionMinor: number; 
    authenticationType: AuthenticationType; 
    solutionId: string; 
    userName: string; 
    emailAddress: string; 
    password: string; 
    domain: string; 
    url: string;

    constructor(data?: any) {
        if (data !== undefined) {
            this.name = data["Name"] !== undefined ? data["Name"] : null;
            this.buildVersioningType = data["BuildVersioningType"] !== undefined ? data["BuildVersioningType"] : null;
            this.versionMajor = data["VersionMajor"] !== undefined ? data["VersionMajor"] : null;
            this.versionMinor = data["VersionMinor"] !== undefined ? data["VersionMinor"] : null;
            this.authenticationType = data["AuthenticationType"] !== undefined ? data["AuthenticationType"] : null;
            this.solutionId = data["SolutionId"] !== undefined ? data["SolutionId"] : null;
            this.userName = data["UserName"] !== undefined ? data["UserName"] : null;
            this.emailAddress = data["EmailAddress"] !== undefined ? data["EmailAddress"] : null;
            this.password = data["Password"] !== undefined ? data["Password"] : null;
            this.domain = data["Domain"] !== undefined ? data["Domain"] : null;
            this.url = data["Url"] !== undefined ? data["Url"] : null;
        }
    }

    static fromJS(data: any): NewBuildRequest {
        return new NewBuildRequest(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["Name"] = this.name !== undefined ? this.name : null;
        data["BuildVersioningType"] = this.buildVersioningType !== undefined ? this.buildVersioningType : null;
        data["VersionMajor"] = this.versionMajor !== undefined ? this.versionMajor : null;
        data["VersionMinor"] = this.versionMinor !== undefined ? this.versionMinor : null;
        data["AuthenticationType"] = this.authenticationType !== undefined ? this.authenticationType : null;
        data["SolutionId"] = this.solutionId !== undefined ? this.solutionId : null;
        data["UserName"] = this.userName !== undefined ? this.userName : null;
        data["EmailAddress"] = this.emailAddress !== undefined ? this.emailAddress : null;
        data["Password"] = this.password !== undefined ? this.password : null;
        data["Domain"] = this.domain !== undefined ? this.domain : null;
        data["Url"] = this.url !== undefined ? this.url : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        const json = this.toJSON();
        return new NewBuildRequest(JSON.parse(json));
    }
}

export class UpdateBuildRequest { 
    id: string; 
    name: string; 
    buildVersioningType: BuildVersioningType; 
    versionMajor: number; 
    versionMinor: number; 
    solutionId: string; 
    authenticationType: AuthenticationType; 
    userName: string; 
    emailAddress: string; 
    password: string; 
    domain: string; 
    url: string;

    constructor(data?: any) {
        if (data !== undefined) {
            this.id = data["Id"] !== undefined ? data["Id"] : null;
            this.name = data["Name"] !== undefined ? data["Name"] : null;
            this.buildVersioningType = data["BuildVersioningType"] !== undefined ? data["BuildVersioningType"] : null;
            this.versionMajor = data["VersionMajor"] !== undefined ? data["VersionMajor"] : null;
            this.versionMinor = data["VersionMinor"] !== undefined ? data["VersionMinor"] : null;
            this.solutionId = data["SolutionId"] !== undefined ? data["SolutionId"] : null;
            this.authenticationType = data["AuthenticationType"] !== undefined ? data["AuthenticationType"] : null;
            this.userName = data["UserName"] !== undefined ? data["UserName"] : null;
            this.emailAddress = data["EmailAddress"] !== undefined ? data["EmailAddress"] : null;
            this.password = data["Password"] !== undefined ? data["Password"] : null;
            this.domain = data["Domain"] !== undefined ? data["Domain"] : null;
            this.url = data["Url"] !== undefined ? data["Url"] : null;
        }
    }

    static fromJS(data: any): UpdateBuildRequest {
        return new UpdateBuildRequest(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["Id"] = this.id !== undefined ? this.id : null;
        data["Name"] = this.name !== undefined ? this.name : null;
        data["BuildVersioningType"] = this.buildVersioningType !== undefined ? this.buildVersioningType : null;
        data["VersionMajor"] = this.versionMajor !== undefined ? this.versionMajor : null;
        data["VersionMinor"] = this.versionMinor !== undefined ? this.versionMinor : null;
        data["SolutionId"] = this.solutionId !== undefined ? this.solutionId : null;
        data["AuthenticationType"] = this.authenticationType !== undefined ? this.authenticationType : null;
        data["UserName"] = this.userName !== undefined ? this.userName : null;
        data["EmailAddress"] = this.emailAddress !== undefined ? this.emailAddress : null;
        data["Password"] = this.password !== undefined ? this.password : null;
        data["Domain"] = this.domain !== undefined ? this.domain : null;
        data["Url"] = this.url !== undefined ? this.url : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        const json = this.toJSON();
        return new UpdateBuildRequest(JSON.parse(json));
    }
}

export class DeleteBuildRequest { 
    id: string;

    constructor(data?: any) {
        if (data !== undefined) {
            this.id = data["Id"] !== undefined ? data["Id"] : null;
        }
    }

    static fromJS(data: any): DeleteBuildRequest {
        return new DeleteBuildRequest(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["Id"] = this.id !== undefined ? this.id : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        const json = this.toJSON();
        return new DeleteBuildRequest(JSON.parse(json));
    }
}

export class GlobalJsonResultOfEmptyResult { 
    successful: boolean; 
    result: EmptyResult; 
    errorMessage: string; 
    stackTrace: string; 
    statusCode: HttpStatusCode;

    constructor(data?: any) {
        if (data !== undefined) {
            this.successful = data["Successful"] !== undefined ? data["Successful"] : null;
            this.result = data["Result"] ? EmptyResult.fromJS(data["Result"]) : null;
            this.errorMessage = data["ErrorMessage"] !== undefined ? data["ErrorMessage"] : null;
            this.stackTrace = data["StackTrace"] !== undefined ? data["StackTrace"] : null;
            this.statusCode = data["StatusCode"] !== undefined ? data["StatusCode"] : null;
        }
    }

    static fromJS(data: any): GlobalJsonResultOfEmptyResult {
        return new GlobalJsonResultOfEmptyResult(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["Successful"] = this.successful !== undefined ? this.successful : null;
        data["Result"] = this.result ? this.result.toJS() : null;
        data["ErrorMessage"] = this.errorMessage !== undefined ? this.errorMessage : null;
        data["StackTrace"] = this.stackTrace !== undefined ? this.stackTrace : null;
        data["StatusCode"] = this.statusCode !== undefined ? this.statusCode : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        const json = this.toJSON();
        return new GlobalJsonResultOfEmptyResult(JSON.parse(json));
    }
}

export class EmptyResult {

    constructor(data?: any) {
        if (data !== undefined) {
        }
    }

    static fromJS(data: any): EmptyResult {
        return new EmptyResult(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        const json = this.toJSON();
        return new EmptyResult(JSON.parse(json));
    }
}

export class GlobalJsonResultOfIEnumerableOfSolutionDto { 
    successful: boolean; 
    result: SolutionDto[]; 
    errorMessage: string; 
    stackTrace: string; 
    statusCode: HttpStatusCode;

    constructor(data?: any) {
        if (data !== undefined) {
            this.successful = data["Successful"] !== undefined ? data["Successful"] : null;
            if (data["Result"] && data["Result"].constructor === Array) {
                this.result = [];
                for (let item of data["Result"])
                    this.result.push(SolutionDto.fromJS(item));
            }
            this.errorMessage = data["ErrorMessage"] !== undefined ? data["ErrorMessage"] : null;
            this.stackTrace = data["StackTrace"] !== undefined ? data["StackTrace"] : null;
            this.statusCode = data["StatusCode"] !== undefined ? data["StatusCode"] : null;
        }
    }

    static fromJS(data: any): GlobalJsonResultOfIEnumerableOfSolutionDto {
        return new GlobalJsonResultOfIEnumerableOfSolutionDto(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["Successful"] = this.successful !== undefined ? this.successful : null;
        if (this.result && this.result.constructor === Array) {
            data["Result"] = [];
            for (let item of this.result)
                data["Result"].push(item.toJS());
        }
        data["ErrorMessage"] = this.errorMessage !== undefined ? this.errorMessage : null;
        data["StackTrace"] = this.stackTrace !== undefined ? this.stackTrace : null;
        data["StatusCode"] = this.statusCode !== undefined ? this.statusCode : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        const json = this.toJSON();
        return new GlobalJsonResultOfIEnumerableOfSolutionDto(JSON.parse(json));
    }
}

export class SolutionDto { 
    name: string; 
    displayName: string; 
    id: string; 
    version: string;

    constructor(data?: any) {
        if (data !== undefined) {
            this.name = data["Name"] !== undefined ? data["Name"] : null;
            this.displayName = data["DisplayName"] !== undefined ? data["DisplayName"] : null;
            this.id = data["Id"] !== undefined ? data["Id"] : null;
            this.version = data["Version"] !== undefined ? data["Version"] : null;
        }
    }

    static fromJS(data: any): SolutionDto {
        return new SolutionDto(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["Name"] = this.name !== undefined ? this.name : null;
        data["DisplayName"] = this.displayName !== undefined ? this.displayName : null;
        data["Id"] = this.id !== undefined ? this.id : null;
        data["Version"] = this.version !== undefined ? this.version : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        const json = this.toJSON();
        return new SolutionDto(JSON.parse(json));
    }
}

export class GlobalJsonResultOfInstallationStatusResult { 
    successful: boolean; 
    result: InstallationStatusResult; 
    errorMessage: string; 
    stackTrace: string; 
    statusCode: HttpStatusCode;

    constructor(data?: any) {
        if (data !== undefined) {
            this.successful = data["Successful"] !== undefined ? data["Successful"] : null;
            this.result = data["Result"] ? InstallationStatusResult.fromJS(data["Result"]) : null;
            this.errorMessage = data["ErrorMessage"] !== undefined ? data["ErrorMessage"] : null;
            this.stackTrace = data["StackTrace"] !== undefined ? data["StackTrace"] : null;
            this.statusCode = data["StatusCode"] !== undefined ? data["StatusCode"] : null;
        }
    }

    static fromJS(data: any): GlobalJsonResultOfInstallationStatusResult {
        return new GlobalJsonResultOfInstallationStatusResult(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["Successful"] = this.successful !== undefined ? this.successful : null;
        data["Result"] = this.result ? this.result.toJS() : null;
        data["ErrorMessage"] = this.errorMessage !== undefined ? this.errorMessage : null;
        data["StackTrace"] = this.stackTrace !== undefined ? this.stackTrace : null;
        data["StatusCode"] = this.statusCode !== undefined ? this.statusCode : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        const json = this.toJSON();
        return new GlobalJsonResultOfInstallationStatusResult(JSON.parse(json));
    }
}

export class InstallationStatusResult { 
    isInstalled: boolean; 
    requiresUpdate: boolean; 
    currentVersion: string;

    constructor(data?: any) {
        if (data !== undefined) {
            this.isInstalled = data["IsInstalled"] !== undefined ? data["IsInstalled"] : null;
            this.requiresUpdate = data["RequiresUpdate"] !== undefined ? data["RequiresUpdate"] : null;
            this.currentVersion = data["CurrentVersion"] !== undefined ? data["CurrentVersion"] : null;
        }
    }

    static fromJS(data: any): InstallationStatusResult {
        return new InstallationStatusResult(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["IsInstalled"] = this.isInstalled !== undefined ? this.isInstalled : null;
        data["RequiresUpdate"] = this.requiresUpdate !== undefined ? this.requiresUpdate : null;
        data["CurrentVersion"] = this.currentVersion !== undefined ? this.currentVersion : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        const json = this.toJSON();
        return new InstallationStatusResult(JSON.parse(json));
    }
}

export class StartInstallationRequest {

    constructor(data?: any) {
        if (data !== undefined) {
        }
    }

    static fromJS(data: any): StartInstallationRequest {
        return new StartInstallationRequest(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        const json = this.toJSON();
        return new StartInstallationRequest(JSON.parse(json));
    }
}

export class GlobalJsonResultOfInstallationResult { 
    successful: boolean; 
    result: InstallationResult; 
    errorMessage: string; 
    stackTrace: string; 
    statusCode: HttpStatusCode;

    constructor(data?: any) {
        if (data !== undefined) {
            this.successful = data["Successful"] !== undefined ? data["Successful"] : null;
            this.result = data["Result"] ? InstallationResult.fromJS(data["Result"]) : null;
            this.errorMessage = data["ErrorMessage"] !== undefined ? data["ErrorMessage"] : null;
            this.stackTrace = data["StackTrace"] !== undefined ? data["StackTrace"] : null;
            this.statusCode = data["StatusCode"] !== undefined ? data["StatusCode"] : null;
        }
    }

    static fromJS(data: any): GlobalJsonResultOfInstallationResult {
        return new GlobalJsonResultOfInstallationResult(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["Successful"] = this.successful !== undefined ? this.successful : null;
        data["Result"] = this.result ? this.result.toJS() : null;
        data["ErrorMessage"] = this.errorMessage !== undefined ? this.errorMessage : null;
        data["StackTrace"] = this.stackTrace !== undefined ? this.stackTrace : null;
        data["StatusCode"] = this.statusCode !== undefined ? this.statusCode : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        const json = this.toJSON();
        return new GlobalJsonResultOfInstallationResult(JSON.parse(json));
    }
}

export class InstallationResult { 
    componentId: number; 
    version: string; 
    isSuccess: boolean; 
    errorMessage: string; 
    moreToInstall: boolean; 
    nextComponentId: number; 
    nextComponentVersion: string; 
    nextComponentDescription: string;

    constructor(data?: any) {
        if (data !== undefined) {
            this.componentId = data["ComponentId"] !== undefined ? data["ComponentId"] : null;
            this.version = data["Version"] !== undefined ? data["Version"] : null;
            this.isSuccess = data["IsSuccess"] !== undefined ? data["IsSuccess"] : null;
            this.errorMessage = data["ErrorMessage"] !== undefined ? data["ErrorMessage"] : null;
            this.moreToInstall = data["MoreToInstall"] !== undefined ? data["MoreToInstall"] : null;
            this.nextComponentId = data["NextComponentId"] !== undefined ? data["NextComponentId"] : null;
            this.nextComponentVersion = data["NextComponentVersion"] !== undefined ? data["NextComponentVersion"] : null;
            this.nextComponentDescription = data["NextComponentDescription"] !== undefined ? data["NextComponentDescription"] : null;
        }
    }

    static fromJS(data: any): InstallationResult {
        return new InstallationResult(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["ComponentId"] = this.componentId !== undefined ? this.componentId : null;
        data["Version"] = this.version !== undefined ? this.version : null;
        data["IsSuccess"] = this.isSuccess !== undefined ? this.isSuccess : null;
        data["ErrorMessage"] = this.errorMessage !== undefined ? this.errorMessage : null;
        data["MoreToInstall"] = this.moreToInstall !== undefined ? this.moreToInstall : null;
        data["NextComponentId"] = this.nextComponentId !== undefined ? this.nextComponentId : null;
        data["NextComponentVersion"] = this.nextComponentVersion !== undefined ? this.nextComponentVersion : null;
        data["NextComponentDescription"] = this.nextComponentDescription !== undefined ? this.nextComponentDescription : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        const json = this.toJSON();
        return new InstallationResult(JSON.parse(json));
    }
}

export class ComponentInstallationRequest { 
    installationComponentId: number; 
    version: string;

    constructor(data?: any) {
        if (data !== undefined) {
            this.installationComponentId = data["InstallationComponentId"] !== undefined ? data["InstallationComponentId"] : null;
            this.version = data["Version"] !== undefined ? data["Version"] : null;
        }
    }

    static fromJS(data: any): ComponentInstallationRequest {
        return new ComponentInstallationRequest(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["InstallationComponentId"] = this.installationComponentId !== undefined ? this.installationComponentId : null;
        data["Version"] = this.version !== undefined ? this.version : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        const json = this.toJSON();
        return new ComponentInstallationRequest(JSON.parse(json));
    }
}

export class RollbackRequest { 
    failedInstallationComponentId: number; 
    failedInstallationVersion: string;

    constructor(data?: any) {
        if (data !== undefined) {
            this.failedInstallationComponentId = data["FailedInstallationComponentId"] !== undefined ? data["FailedInstallationComponentId"] : null;
            this.failedInstallationVersion = data["FailedInstallationVersion"] !== undefined ? data["FailedInstallationVersion"] : null;
        }
    }

    static fromJS(data: any): RollbackRequest {
        return new RollbackRequest(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["FailedInstallationComponentId"] = this.failedInstallationComponentId !== undefined ? this.failedInstallationComponentId : null;
        data["FailedInstallationVersion"] = this.failedInstallationVersion !== undefined ? this.failedInstallationVersion : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        const json = this.toJSON();
        return new RollbackRequest(JSON.parse(json));
    }
}

export class GlobalJsonResultOfRollbackResult { 
    successful: boolean; 
    result: RollbackResult; 
    errorMessage: string; 
    stackTrace: string; 
    statusCode: HttpStatusCode;

    constructor(data?: any) {
        if (data !== undefined) {
            this.successful = data["Successful"] !== undefined ? data["Successful"] : null;
            this.result = data["Result"] ? RollbackResult.fromJS(data["Result"]) : null;
            this.errorMessage = data["ErrorMessage"] !== undefined ? data["ErrorMessage"] : null;
            this.stackTrace = data["StackTrace"] !== undefined ? data["StackTrace"] : null;
            this.statusCode = data["StatusCode"] !== undefined ? data["StatusCode"] : null;
        }
    }

    static fromJS(data: any): GlobalJsonResultOfRollbackResult {
        return new GlobalJsonResultOfRollbackResult(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["Successful"] = this.successful !== undefined ? this.successful : null;
        data["Result"] = this.result ? this.result.toJS() : null;
        data["ErrorMessage"] = this.errorMessage !== undefined ? this.errorMessage : null;
        data["StackTrace"] = this.stackTrace !== undefined ? this.stackTrace : null;
        data["StatusCode"] = this.statusCode !== undefined ? this.statusCode : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        const json = this.toJSON();
        return new GlobalJsonResultOfRollbackResult(JSON.parse(json));
    }
}

export class RollbackResult { 
    currentVersion: string;

    constructor(data?: any) {
        if (data !== undefined) {
            this.currentVersion = data["CurrentVersion"] !== undefined ? data["CurrentVersion"] : null;
        }
    }

    static fromJS(data: any): RollbackResult {
        return new RollbackResult(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["CurrentVersion"] = this.currentVersion !== undefined ? this.currentVersion : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        const json = this.toJSON();
        return new RollbackResult(JSON.parse(json));
    }
}

export class GlobalJsonResultOfBoolean { 
    successful: boolean; 
    result: boolean; 
    errorMessage: string; 
    stackTrace: string; 
    statusCode: HttpStatusCode;

    constructor(data?: any) {
        if (data !== undefined) {
            this.successful = data["Successful"] !== undefined ? data["Successful"] : null;
            this.result = data["Result"] !== undefined ? data["Result"] : null;
            this.errorMessage = data["ErrorMessage"] !== undefined ? data["ErrorMessage"] : null;
            this.stackTrace = data["StackTrace"] !== undefined ? data["StackTrace"] : null;
            this.statusCode = data["StatusCode"] !== undefined ? data["StatusCode"] : null;
        }
    }

    static fromJS(data: any): GlobalJsonResultOfBoolean {
        return new GlobalJsonResultOfBoolean(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["Successful"] = this.successful !== undefined ? this.successful : null;
        data["Result"] = this.result !== undefined ? this.result : null;
        data["ErrorMessage"] = this.errorMessage !== undefined ? this.errorMessage : null;
        data["StackTrace"] = this.stackTrace !== undefined ? this.stackTrace : null;
        data["StatusCode"] = this.statusCode !== undefined ? this.statusCode : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        const json = this.toJSON();
        return new GlobalJsonResultOfBoolean(JSON.parse(json));
    }
}

export class NewSessionRequest { 
    authenticationType: AuthenticationType; 
    userName: string; 
    emailAddress: string; 
    password: string; 
    domain: string; 
    url: string;

    constructor(data?: any) {
        if (data !== undefined) {
            this.authenticationType = data["AuthenticationType"] !== undefined ? data["AuthenticationType"] : null;
            this.userName = data["UserName"] !== undefined ? data["UserName"] : null;
            this.emailAddress = data["EmailAddress"] !== undefined ? data["EmailAddress"] : null;
            this.password = data["Password"] !== undefined ? data["Password"] : null;
            this.domain = data["Domain"] !== undefined ? data["Domain"] : null;
            this.url = data["Url"] !== undefined ? data["Url"] : null;
        }
    }

    static fromJS(data: any): NewSessionRequest {
        return new NewSessionRequest(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["AuthenticationType"] = this.authenticationType !== undefined ? this.authenticationType : null;
        data["UserName"] = this.userName !== undefined ? this.userName : null;
        data["EmailAddress"] = this.emailAddress !== undefined ? this.emailAddress : null;
        data["Password"] = this.password !== undefined ? this.password : null;
        data["Domain"] = this.domain !== undefined ? this.domain : null;
        data["Url"] = this.url !== undefined ? this.url : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        const json = this.toJSON();
        return new NewSessionRequest(JSON.parse(json));
    }
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    result?: any; 

    constructor(message: string, status: number, response: string, result?: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.result = result;
    }
}

interface FetchOptions {
    method?: "GET" | "POST" | "DELETE" | "PATCH" | "PUT" | "Options";
    headers ?: any;
            body ?: any;
            mode ?: "cors" | "no -cors" | "same -origin";
            credentials ?: "omit" | "same -origin" | "include";
            cache ?: "default" | "no -store" | "reload" | "no -cache" | "force -cache" | "only -if-cached";
            redirect ?: "follow" | "error" | "manual";
            referrer ?: string;
            referrerPolicy ?: "referrer" | "no-referrer-when-downgrade" | "origin" | "origin-when-cross-origin" | "unsafe-url";
            integrity ?: any;
}

declare enum ResponseType {
    Basic,
    Cors,
    Default,
    Error,
    Opaque
}

interface Headers {
    append(name: string, value: string):void;
    delete(name: string):void;
    get(name: string): string;
    getAll(name: string): Array<string>;
    has(name: string): boolean;
    set(name: string, value: string): void;
}

interface Body {
    bodyUsed: boolean;
    arrayBuffer(): Promise<ArrayBuffer>;
    blob(): Promise<Blob>;
    formData(): Promise<FormData>;
    json(): Promise<JSON>;
    text(): Promise<string>;
}

interface Response extends Body {
    error(): Response;
    redirect(url: string, status?: number): Response;
	type: ResponseType;
	url: string;
	status: number;
	ok: boolean;
	statusText: string;
	headers: Headers;

    clone(): Response;
}

interface Window {
    fetch(url: string): Promise<Response>;
    fetch(url: string, options: FetchOptions): Promise<Response>;
}

interface RequestInit {
}

interface RequestInfo {
}